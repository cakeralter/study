[TOC]

## Java基础笔记

### 1. `char`、`byte`、`short`两两运算结果（包括自己与自己）为`int`

> char、byte、short -> int -> long -> float -> double

```java
byte a = 12;
byte b = 14;
byte c = b + c; // 编译出错 int --/-> byte
```

### 2. 整型默认为`int`，浮点型默认为`double`

### 3. 原码、反码、补码（计算机存储一律使用补码）

- 正数三码合一

```java
12 => 0000 1100 => 0000 1100 => 0000 1100
```

- 负数反码为原码取反，补码为反码加一(符号位不变)

```java
-12 => 1000 1100 => 1111 0011 => 1111 0100
```

### 4. 进制转换技巧

1. 10进制↔2进制↔8进制

```java
12 = 0b00_001_100 = 01_4
```

2. 10进制↔2进制↔16进制

```java
12 = 0b0000_1100 = 0x0_C
```

### 5. ++ -- += -=等赋值运算符不会改变变量本身数据类型

```java
byte a = 12;
a = a + 12; // 编译出错 int --/-> byte
a+=12; // success
a = a + 1;; // 编译出错 int --/-> byte
a++; // success
```

### 6. 异或运算交换两个数值类型变量

> a ^ b ^ b = a ^ (b ^ b) = a

```java
int a = 12;
int b = 17;

a = a ^ b;
b = a ^ b;
a = a ^ b;
```

### 7. 一定范围内，x << n运算等于 x * 2^n^，x >> n运算等于x / 2^n^

```java
2 * 8 = 2 << 3 = 8 << 1
8 / 2 = 8 >> 1
```

### 8. 位运算进制转换

```java
// 0b0010_0101(37) 转为16进制
int bin = 0b0011_1101;
int suf = bin & ((2 << 3) - 1); // 取bin的后四位0101 即 bin & 15
int pre = bin >>> 4; // bin无符号右移4位 将前四位数移至尾部
pre = pre & ((2 << 3) - 1);

String prefix = pre > 9 ? (char) ('A' + (pre - 10)) + "" : pre + "";
String suffix = suf > 9 ? (char) ('A' + (suf - 10)) + "" : suf + "";

System.out.println("0x" + prefix + suffix); // 0x3D
```

### 9. `switch`表达式只能使用`char`、`byte`、`short`、`int`、枚举、`String`等几种类型

### 10. 引用类型变量要么为`null`，要么为地址值

### 11. 成员变量和局部变量的区别

1. 成员变量和局部变量声明位置不同
2. 成员变量有默认值，可以不赋初始化值；局部变量必须给定初始值
3. 成员变量可以用权限修饰符控制访问；局部变量不可以
4. 成员变量和局部变量在内存中的位置不同

### 12. 重载(overload)的一些总结：两同一不同

- 同一个类中
- 方法名相同
- 参数列表不同：参数个数不同或者参数类型不同

### 13. Java的值传递机制

- 基本类型传递参数值
- 引用类型传递引用的地址值

### 14 `this`构造器只能在构造器首行调用，即只能调用一次

### 15. 子类继承父类所有的属性和方法。`private` 等修饰的属性或方法也会被继承，但访问受限

### 16. 方法重写（Override）的细节

1. 重写方法和被重写方法的方法名、参数列表相同
2. 重写方法的访问权限不能小于被重写方法的访问权限
3. 从返回值类型来看：
- 被重写方法返回值类型为void或基本类型，则重写方法返回值类型必须为void或基本类型
- 被重写方法返回值类型为引用类型，则重写方法返回值类型必须为相同类型或其子类型
4. 重写方法抛出异常类型必须和被重写方法一致或为其子类型异常

### 17. 对象的多态性

1. 多态可以理解为一个事物的多种形态
2. 何为多态性：父类的引用指向子类的对象
3. 多态的使用（虚拟方法调用）：编译看左边，运行看右边
4. 多态的前提：
- 继承关系
- 方法重写
5. 对象的多态性只适用于方法，不适用于属性
6. 多态是运行时行为

### 18. 对象加载过程代码块及构造函数的执行顺序

父类静态代码块 -> 子类静态代码块 -> 父类代码块 -> 父类构造函数 -> 子类代码块 -> 子类构造函数

### 19. 类属性可赋值顺序

默认初始化 -> 显式赋值 / 代码块赋值 -> 构造器赋值 -> 方法赋值

> 显式赋值和代码块执行看具体代码顺序

### 20. 在局部类的方法中如果要调用其声明域内的变量，则要求改变量必须用 `final` 修饰

因为外部类和局部内部类生命周期不一致，外部类传递的实际上是该变量的一个副本，故而要求其必须用 `final` 修饰

### 21. `throw` 和 `throws` 

- `throw` 表示抛出一个异常对象，属于生成异常对象的过程。声明在方法体中。
- `throws` 属于异常处理的一种方式，声明在方法声明处。

### 22. 一个Java程序启动时至少有3个线程：`main` 方法线程、`gc` 线程以及异常处理线程

### 23. Java线程状态转换图

![Java线程状态转换图](https://gitee.com/cakeralter/images/raw/master/20200727210059.png)

### 24. `Thread` 使用几点总结：

1. 不能直接调用 `run()` 来启动线程

> 调用 `Thread` 的 `start()` 方法会启动 `Thread` 线程执行 `run()`，直接调用 `run()` 则只是在当前线程执行

2. 不能多次调用线程对象的 `start()` 方法，会报 `IllegalThreadStateException` 异常

### 25. 线程常用方法：

- `Thread` 类中的方法

1. **start()** ：启动 `Thread` 线程；通知JVM调用线程的 `run()`
2. **run()** ：定义当前线程具体的执行逻辑
3. **currentThread()** ：获取当前线程对象
4. **setName(String name)** ：设置线程名
5. **getName()** ：获取线程名
6. **sleep(long millis)** ：使调用线程阻塞指定毫秒时间
7. **join()** ：在线程A中调用线程B的 `join()` ，则线程A进入阻塞状态直到线程B执行完毕，之后退出阻塞重新等待CPU调度
8. **yield()** ：使调用线程释放CPU执行权，CPU重新进行调度
9. **setPriority(int newPriority)** ：设置线程优先级
10. **getPriority()** ：获取线程优先级
11. **isAlive()** ：测试线程是否存活
12. **interrupt()** ：中断线程
13. **interrupted()** ：测试线程是否已中断
14. **setDaemon(boolean on)** ：是否将线程设置为守护线程
15. **isDaemon()** ：测试线程是否为守护线程

- `Object` 类中的方法

### 26. 