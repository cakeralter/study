[TOC]

## Java基础笔记

### 1. `char`、`byte`、`short`两两运算结果（包括自己与自己）为`int`

> char、byte、short -> int -> long -> float -> double

```java
byte a = 12;
byte b = 14;
byte c = b + c; // 编译出错 int --/-> byte
```

### 2. 整型默认为`int`，浮点型默认为`double`

### 3. 原码、反码、补码（计算机存储一律使用补码）

- 正数三码合一

```java
12 => 0000 1100 => 0000 1100 => 0000 1100
```

- 负数反码为原码取反，补码为反码加一(符号位不变)

```java
-12 => 1000 1100 => 1111 0011 => 1111 0100
```

### 4. 进制转换技巧

1. 10进制↔2进制↔8进制

```java
12 = 0b00_001_100 = 01_4
```

2. 10进制↔2进制↔16进制

```java
12 = 0b0000_1100 = 0x0_C
```

### 5. ++ -- += -=等赋值运算符不会改变变量本身数据类型

```java
byte a = 12;
a = a + 12; // 编译出错 int --/-> byte
a+=12; // success
a = a + 1;; // 编译出错 int --/-> byte
a++; // success
```

### 6. 巧妙位运算

> [优秀程序员不得不知道的20个位运算技巧](https://www.cnblogs.com/qiaogaojian/p/5873105.html)

- 异或运算交换两个数值类型变量

> a ^ b ^ b = a ^ (b ^ b) = a

```java
int a = 12;
int b = 17;

a = a ^ b;
b = a ^ b;
a = a ^ b;
```

- 位运算取最大(小)值

```java
// 取最小值
b & ((b - a) >> 31) | a & (~(b - a) >> 31)
// 取最大值
a & ((a - b) >> 31) | b & (~(a - b) >> 31)
```

### 7. 一定范围内，x << n运算等于 x * 2^n^，x >> n运算等于x / 2^n^

```java
2 * 8 = 2 << 3 = 8 << 1
8 / 2 = 8 >> 1
```

### 8. 位运算进制转换

```java
// 0b0010_0101(37) 转为16进制
int bin = 0b0011_1101;
int suf = bin & ((2 << 3) - 1); // 取bin的后四位0101 即 bin & 15
int pre = bin >>> 4; // bin无符号右移4位 将前四位数移至尾部
pre = pre & ((2 << 3) - 1);

String prefix = pre > 9 ? (char) ('A' + (pre - 10)) + "" : pre + "";
String suffix = suf > 9 ? (char) ('A' + (suf - 10)) + "" : suf + "";

System.out.println("0x" + prefix + suffix); // 0x3D
```

### 9. `switch`表达式只能使用`char`、`byte`、`short`、`int`、枚举、`String`等几种类型

### 10. 引用类型变量要么为`null`，要么为地址值

### 11. 成员变量和局部变量的区别

1. 成员变量和局部变量声明位置不同
2. 成员变量有默认值，可以不赋初始化值；局部变量必须给定初始值
3. 成员变量可以用权限修饰符控制访问；局部变量不可以
4. 成员变量和局部变量在内存中的位置不同

### 12. 重载(overload)的一些总结：两同一不同

- 同一个类中
- 方法名相同
- 参数列表不同：参数个数不同或者参数类型不同

### 13. Java的值传递机制

- 基本类型传递参数值
- 引用类型传递引用的地址值

### 14 `this`构造器只能在构造器首行调用，即只能调用一次

### 15. 子类继承父类所有的属性和方法。`private` 等修饰的属性或方法也会被继承，但访问受限

### 16. 方法重写（Override）的细节

1. 重写方法和被重写方法的方法名、参数列表相同
2. 重写方法的访问权限不能小于被重写方法的访问权限
3. 从返回值类型来看：
- 被重写方法返回值类型为void或基本类型，则重写方法返回值类型必须为void或基本类型
- 被重写方法返回值类型为引用类型，则重写方法返回值类型必须为相同类型或其子类型
4. 重写方法抛出异常类型必须和被重写方法一致或为其子类型异常

### 17. 对象的多态性

1. 多态可以理解为一个事物的多种形态
2. 何为多态性：父类的引用指向子类的对象
3. 多态的使用（虚拟方法调用）：编译看左边，运行看右边
4. 多态的前提：
- 继承关系
- 方法重写
5. 对象的多态性只适用于方法，不适用于属性
6. 多态是运行时行为

### 18. 对象加载过程代码块及构造函数的执行顺序

父类静态代码块 -> 子类静态代码块 -> 父类代码块 -> 父类构造函数 -> 子类代码块 -> 子类构造函数

### 19. 类属性可赋值顺序

默认初始化 -> 显式赋值 / 代码块赋值 -> 构造器赋值 -> 方法赋值

> 显式赋值和代码块执行看具体代码顺序

### 20. 在局部类的方法中如果要调用其声明域内的变量，则要求改变量必须用 `final` 修饰

因为外部类和局部内部类生命周期不一致，外部类传递的实际上是该变量的一个副本，故而要求其必须用 `final` 修饰

### 21. `throw` 和 `throws` 

- `throw` 表示抛出一个异常对象，属于生成异常对象的过程。声明在方法体中。
- `throws` 属于异常处理的一种方式，声明在方法声明处。

### 22. `String` 类总结

1. `String` 类被 `final` 修饰，说明其不可被继承
2. `String` 类实现了 `Serializable` 接口，说明其可以序列化
3. `String` 类实现了 `Comparable` 接口，说明其可以比较大小
4. `String` 类使用 `char` 数组存储字符，并且数组被 `final` 修饰
5. `String` 类中的字符序列是不可变的
6. 通过字面量声明一个字符串时，该字符串会存储在字符串常量池中（常量池已经存在直接返回引用，常量池不存在则先在常量池创建字符串后返回引用）
7. 通过构造器声明一个字符串时，会在堆中创建一个对象后返回对象的引用（该对象中存储的是常量池中字符串的引用值）

### 23. `String` 、`StringBuffer` 及 `StringBuilder`

- **String** ：不可变的字符序列，底层是 `char` 数组
- **StringBuffer** ：可变的字符序列，底层是 `char` 数组；线程安全，效率低
- **StringBuilder** ：可变的字符序列，底层是 `char` 数组；线程不安全，效率高

### 24. 序列化

> `static` 和 `transient` 修饰的属性不会被序列化

1. 对象可序列化要求：

   - 序列化类需要实现 `Serializable` 或者 `Externalizable` 接口

   - 序列化类需要提供静态常量属性 `serialVersionUID`
   - 序列化类的属性要求必须是可序列化的